

==========================================================================


#include <iostream>
#include <vector>
#include <queue>
#include <list>
#include "save.h"

using namespace std;

int main()
{
	// size (resize)
	// list는 capacity 개념 없음
	// 삽입/삭제?
	// 시간 복잡도 0.1초만에 대답할 수 있어야 함!!!
	// - 시작		O(1)	위치를 알고 있을 때 O(1)
	// - 중간		O(1)
	// - 끝			O(1)
	// front		O(1)
	// back			O(1)
	// push_front	O(1)
	// push_back	O(1)
	// 임의 접근 li[2]	지원하지 않음

	list<int> li{ 1,2,3,4,5 };

	li.insert(li.end(), 1);
	li.insert(li.end(), 2);
	list<int>::iterator it = li.insert(li.end(), 3);
	li.insert(li.end(), 4);
	li.insert(li.end(), 5);

	li.erase(it);

	save("cpp.cpp");
}

==========================================================================


#include <iostream>
#include <vector>
#include <queue>
#include <list>
#include "save.h"

using namespace std;

int main()
{
	// size (resize)
	// list는 capacity 개념 없음
	// 삽입/삭제?
	// 시간 복잡도 0.1초만에 대답할 수 있어야 함!!!
	// - 시작		O(1)	위치를 알고 있을 때 O(1)
	// - 중간		O(1)
	// - 끝			O(1)
	// front		O(1)
	// back			O(1)
	// push_front	O(1)
	// push_back	O(1)
	// 임의 접근 li[2]	지원하지 않음

	list<int> li{ 1,2,3,4,5 };

	list<int>::iterator it;

	// 데이터를 찾는 방식은 vector와 동일함
	for (list<int>::iterator it = li.begin(); it != li.end(); ++it)
	{
		int value = *it;
		if (value == 3)
			break; 
		cout << value << endl;
	}

	if (it != li.end())
	{
		cout << "3을 찾았다!" << endl;
	}

	save("cpp.cpp");
}


=========================================================================


#include <iostream>
#include <vector>
#include <queue>
#include <list>
#include "List.h"
#include "save.h"

using namespace std;

int main()
{
	// size (resize)
	// list는 capacity 개념 없음
	// 삽입/삭제?
	// 시간 복잡도 0.1초만에 대답할 수 있어야 함!!!
	// - 시작		O(1)	위치를 알고 있을 때 O(1)
	// - 중간		O(1)
	// - 끝			O(1)
	// front		O(1)
	// back			O(1)
	// push_front	O(1)
	// push_back	O(1)
	// 임의 접근 li[2]	지원하지 않음

	List<int> li;
	li.AddAtTail(10);
	li.AddAtTail(20);
	li.AddAtTail(30);

	for (List<int>::iterator it = li.begin(); it != li.end();)
	{
		int value = *it;
		cout << value << endl;
	}
	save("cpp.cpp");
}

// i