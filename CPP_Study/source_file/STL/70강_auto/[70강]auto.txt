

==========================================================================


#include <iostream>
#include <vector>
#include <queue>
#include <list>
#include "save.h"
using namespace std;

// auto

class Knight
{

};

template<typename T>
void Print(T t)
{
	cout << t << endl;
}

int main()
{
	// C++03 - 우리가 배우고 있는 것
	// C++11 (Modern C++) - 유용한 문법 많이 추가됨
	// C++14
	// C++17
	// C++20 (대격변)
	{
		int a = 3;
		float b = 3.14f;
		double c = 1.23;
		Knight* d = new Knight();
		const char* e = "Hello";
	}
	
	{
		 auto a = 3;
		 auto b = 3.14f;
		 auto c = 1.23;
		 auto d = new Knight();
		 auto e = "Hello";

		 // compile time에 결정
		 //
		 // 형식 연역 (type decuction)
		 // -> 말이 되게 잘 맞춰봐? 추론

		 int& ref = a;
		 const int cst = a;

		 // 주의! auto는 const, &는 떼고 추론한다?
		 auto ref2 = ref;	// int타입임, 원본은 참조 타입이지만
		 auto cst2 = cst;	// int 타입

		 auto& ref3 = ref;
		 const auto cst3 = cst;
	}

	// auto는 일종의 조커카드
	// Print(1);
	// Print("Hello");

	save("cpp.cpp");
}


==========================================================================


#include <iostream>
#include <vector>
#include <queue>
#include <list>
#include "save.h"
using namespace std;

// auto

class Knight
{

};

template<typename T>
void Print(T t)
{
	cout << t << endl;
}

int main()
{
	// auto
	// 컴파일 시점에 결정되기 때문에 성능 차이는 없음!
	// 장점 : 타이핑 - iterator 사용할 때!!!
	// vector<int> v;
	// vector<int>::iterator (X) auto it = v.begin(); 간결
	// 단점 : 가독성이 낮음

	{
		 vector<int> v{ 1,2,3,4,5 };

		 for (int i = 0; i < v.size(); ++i)
		 {
			 auto& value = v[i];		// 원본 값을 건드리고 싶을 때
			 // 참조자를 쓰지 않으면 복사가 되는 것!
			 if (value < 5)
			 {

			 }
		 }
	}

	// auto는 일종의 조커카드
	// Print(1);
	// Print("Hello");

	save("cpp.cpp");
}
