

==========================================================================
fileName ::, 2024-07-20 ����� ���� 1:17:29
==========================================================================


﻿#include <iostream>
#include "save.h"

int main()
{
   // C 스타일 캐스팅

    // 값 타입 변환
    // 특징) 의미를 유지하기 위해서 원본 객체와 다른 비트열 재구성
    {
        int a = 123456789;
        float b = (float)a;     
        // b의 값은 1234567892. 
        // float는 근삿값 -> 큰 숫자를 사용하면 오차 발생할 수 
        int c = 0;
    }
    // 참조 타입 변환
    {
        int a = 123456789;
        float b = (float&)a;    
        // b의 값은 1.65359970e-34
        // a의 메모리에 있는 값을 float로 바꾼 것
        int c = 0;
    }
    // 코드는 비슷해 보이지만, 완전히 다른 동작이다
    
    save("RPGGAME.cpp");
}

==========================================================================
fileName ::, 2024-07-20 ����� ���� 1:21:02
==========================================================================


﻿#include <iostream>
#include "save.h"

int main()
{
   // C 스타일 캐스팅

    // 값 타입 변환
    // 특징) 의미를 유지하기 위해서 원본 객체와 다른 비트열 재구성
    {
        int a = 123456789;
        float b = (float)a;     
        // b의 값은 1234567892. 
        // float는 근삿값 -> 큰 숫자를 사용하면 오차 발생할 수 
        int c = 0;
    }
    // 참조 타입 변환
    {
        int a = 123456789;
        float b = (float&)a;    
        // b의 값은 1.65359970e-34
        // a의 메모리에 있는 값을 float로 바꾼 것
        int c = 0;
    }
    // 코드는 비슷해 보이지만, 완전히 다른 동작임
    
    // 안전한 변환 (의미가 100% 일치)
    {
        int a = 123456789;
        _int64 b = (_int64)a;
        int c = 0;
    }
    {
        int a = 123456789;
        short b = (short)a;     // 바구니가 큰 int에서 작은 short로 변했으니 일부 값이 손실됨
        int c = 0;
    }
    save("RPGGAME.cpp");
}

==========================================================================
fileName ::, 2024-07-20 ����� ���� 1:23:33
==========================================================================


﻿#include <iostream>
#include "save.h"

int main()
{
   // C 스타일 캐스팅

    // 값 타입 변환
    // 특징) 의미를 유지하기 위해서 원본 객체와 다른 비트열 재구성
    {
        int a = 123456789;
        float b = (float)a;     
        // b의 값은 1234567892. 
        // float는 근삿값 -> 큰 숫자를 사용하면 오차 발생할 수 
        int c = 0;
    }
    // 참조 타입 변환 - 거의 쓸 일 없으니 잊어도 됨!
    {
        int a = 123456789;
        float b = (float&)a;    
        // b의 값은 1.65359970e-34
        // a의 메모리에 있는 값을 float로 바꾼 것
        int c = 0;
    }
    // 코드는 비슷해 보이지만, 완전히 다른 동작임
    
    // 안전한 변환 (의미가 100% 일치)
    {
        int a = 123456789;
        _int64 b = (_int64)a;
        int c = 0;
    }
    // 불완전한 변환
    {
        int a = 123456789;
        short b = (short)a;     // 바구니가 큰 int에서 작은 short로 변했으니 일부 값이 손실됨
        int c = 0;
    }
    
    // 암시적
    {
        int a = 123456789;
        float b = a;       // float b = (float)a; 이 코드와 같음 얘는 명시적
    }
    save("RPGGAME.cpp");
}

==========================================================================
fileName ::, 2024-07-20   2:07:54
==========================================================================


﻿#include <iostream>
#include "save.h"

class Player
{

};

class Knight : public Player
{
public:
    int hp;
    int defence;
};

class Dog
{
public:
    int age;
    int size;
};

int main()
{
    // C 스타일 캐스팅

    Knight* k = new Knight();
     
    Dog* dog = (Dog*)k;     // 오류가 발생하지 않음
    // 포인터는 타고 갔더니 얘가 있다는 거라고 주장하는 것 실제 값은 모르니까

    dog->age = 10;  // 형변환을 해서 사용하면 문제가 발생할까? - ㅇㅇ!!!
    save("RPGGAME.cpp");
}
