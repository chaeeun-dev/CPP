

==========================================================================


#include <iostream>
#include <unordered_map>
#include "save.h"
using namespace std;

class Knight
{
public:
	~Knight() { }

	void Attack()
	{
		//if (_target)
		//	_target->_hp -= -_damage;
	}

public:
	int _hp = 100;
	int _damage = 10;

	//Knight* _target = nullptr;	// 주시 대상 설정
	int targetid = 0;
};

int main()
{
	Knight* knight = new Knight();
	// delete를 하지 않으면... 메모리 leak 발생 할 수 있음

	// shared_ptr
	// weak_ptr
	// unique_ptr

	Knight* k1 = new Knight();
	Knight* k2 = new Knight();

	//k1->_target = k2;

	delete k2;

	k1->Attack();
	// k2가 접속 종료를 하면 문제 발생!
	// use after free

	// ex. 포폴 만들 때, 뮤탈을 죽였더니 게임도 죽는 경우가 있음!!!
	// 해결 방법? 포인터로 들고있지 말고, 아이디로 들고있자(스마트포인터 안 쓸 거라면)


	save("cpp.cpp");
}
 

==========================================================================


#include <iostream>
#include <unordered_map>
#include "save.h"
using namespace std;

class Knight
{
public:
	~Knight() { }

	void Attack()
	{
		//if (_target)
		//	_target->_hp -= -_damage;
	}

public:
	int _hp = 100;
	int _damage = 10;

	Knight* _target = nullptr;	// 주시 대상 설정
};

class RefCountBlock
{
public:
	int _refCount = 1;
};

template<typename T>
class SharedPtr
{
public:
	SharedPtr() { }

	SharedPtr(T* ptr) : _ptr(ptr) 
	{
		if (ptr)
		{
			_block = new RefCountBlock();
			cout << "RefCount : " << _block->_refCount << endl;
		}
	}

	SharedPtr(const SharedPtr& other) : _ptr(other._ptr), _block(other._block)
	{
		if (_ptr)
		{
			_block->_refCount++;
		}
	}

	void operator=(const SharedPtr& other)
	{
		_ptr = other._ptr;
		_block = other._block;

		if (_ptr)
			_block->_refCount++;
	}

	~SharedPtr()
	{
		if (_ptr)
		{
			_block->_refCount--;

			if (_block->_refCount == 0)
			{
				delete _ptr;
				delete _block;
				cout << "Delete Data" << endl;
			}
		}
	}

public:
	T* _ptr = nullptr;
	RefCountBlock* _block = nullptr;
};

int main()
{
	// shared_ptr
	// weak_ptr
	// unique_ptr

	SharedPtr<Knight> k1(new Knight());
	SharedPtr<Knight> k2(new Knight());

	SharedPtr<Knight> k3;
	k3 = k1;	// k3과 k1이 동일한 knight 객체를 가리킴
	// 객체를 Shared_ptr이 관리, 복사가 일어날 때마다 refCount++
	// 객체가 소멸될 때 refCount-- 

	save("cpp.cpp");
}
 

 // Shared_ptr 간단 정리 
 // 일반 포인터와 동일하게 사용하지만,
 // 내부적으로 참조 카운트를 두어 객체가 몇 개인지 추적
 // Shared_ptr을 복사하는 순간에 참조 카운트 1증가
