

==========================================================================
fileName ::, 2024-07-30 화요일 오후 2:55:05
==========================================================================


#include <iostream>
#include "save.h"

// Vector/List -> Tree ->Graph -> BFS -> Dijikstra -> A*(PQ)

// 재귀함수
void Func(int a)
{
	std::cout << a << std::endl;

	Func(a - 1);
}

int main()
{	
	save("cpp.cpp");
	
	Func(5);
	// 이 함수가 실행되면 크래시가 발생하는 원인을 설명할 수 있어야함!
	// 왜 stackoverflow가 발생하는가? 
	// 할당한 스택 프레임을 반환해야 하는데, 재귀 함수로 계속 스텍 프레임을 할당 받으니까
	// 이전의 스택 프레임이 반환되지 않아 메모리가 고갈된다.
	// 재귀 함수를 사용할 때는 조심하기


}

==========================================================================
fileName ::, 2024-07-30 화요일 오후 2:56:09
==========================================================================


#include <iostream>
#include "save.h"

// Vector/List -> Tree ->Graph -> BFS -> Dijikstra -> A*(PQ)

// 재귀함수
void Func(int a)
{
	std::cout << a << std::endl;

	Func(a - 1);
}

int main()
{	
	save("cpp.cpp");
	
	Func(5);
	// 이 함수가 실행되면 크래시가 발생하는 원인을 설명할 수 있어야함!
	// 왜 stackoverflow가 발생하는가? 
	// 할당한 스택 프레임을 반환해야 하는데, 재귀 함수로 계속 스텍 프레임을 할당 받으니까
	// 이전의 스택 프레임이 반환되지 않아 메모리가 고갈된다.
	// 재귀 함수를 사용할 때는 조심하기


}

==========================================================================
fileName ::, 2024-07-30 화요일 오후 3:07:15
==========================================================================


#include <iostream>
#include "save.h"

// Vector/List -> Tree ->Graph -> BFS -> Dijikstra -> A*(PQ)

// 재귀함수
void Func(int a)
{
	std::cout << a << std::endl;

	Func(a - 1);
}

// for문을 사용하지 않고, 재귀함수를 사용하면 좋은 점?
// 더 편하게 사용할 수 있음, 근데 조건을 제대로 써야함! 

// 팩토리얼
// n! = n * (n - 1)!
int Factorial(int n)
{
	if (n <= 1)
		return 1;

	return n * Factorial(n - 1);
}

// 면접 질문으로 나온 알고리즘 - 유클리드 호제법(최대 공약수)
// a > b
// GCD(1029, 1071)
// = GCD(1029, 1071%1029=42)
// = GCD(42, 1029%42=21)
// = GCD(21, 42%21=0)
int GCD(int a, int b)
{
	if (b == 0)
		return a;

	return GCD(b, a % b);
}

int main()
{	
	GCD(1071, 1029); 

	save("cpp.cpp");
}