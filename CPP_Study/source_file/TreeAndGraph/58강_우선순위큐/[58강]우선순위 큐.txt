

==========================================================================


#include <iostream>
#include <vector>
#include "save.h"

template<typename T>
class PriorityQueue
{
public:
	void push(const T& data)
	{
		// 우선 힙 구조부터 맞춰준다 - 그냥 끝에 채워 넣음
		_heap.push_back(data);

		// 도장 깨기 시작 
		int now = static_cast<int>(_heap.size()) - 1;

		// 루트 노드까지
		while (now > 0)
		{
			// 부모 노드와 비교해서 더 작으면 패배
			int next = (now - 1) / 2;	// 부모 노드의 인덱스
			if (_heap[now] < _heap[next])
				break;	// while문을 빠져 나온다

			// 데이터 교체
			std::swap(_heap[now], _heap[next]);

			now = next;
		}
	}

	void pop()	// 데이터 꺼내기
	{
		_heap[0] = _heap.back();	// 맨 위 노드의 데이터를 맨 뒤 노드 데이터로 덮어씀
		_heap.pop_back();	// 맨 뒤에 노드 삭제

		int now = 0; // 현재 노드는 맨 위에서 시작

		while (true)
		{
			int left = 2 * now + 1;
			int right = 2 * now + 2;

			// 리프에 도달한 경우
			if (left >= (int)_heap.size())
				break;

			int next = now;

			// 왼쪽 비교
			if (_heap[next] < _heap[left])	// now가 왼쪽보다 작으면
				next = left;	// 왼쪽으로 내려감

			// 둘 중 승자를 오른쪽과 비교
			if (right < _heap.size() && _heap[next] < _heap[right])
				next = right;

			// 왼쪽/오른쪽 둘 다 현재 값보다 작으면 종료
			if (next == now)
				break;

			std::swap(_heap[now], _heap[next]);
		}
	}

	T& top()	// 현재 제일 좋은 값 - 0 번째 데이터가 가장 큼
	{
		return _heap[0];
	}

	bool Empty()	// 데이터가 있는지 여부 
	{
		return _heap.empty();
	}

private:
	std::vector<T> _heap;	// 데이터를 동적으로 관리할 수 있는 vecotor
};
int main()
{   
	std::vector<int> v;
	PriorityQueue<int> pq;

	pq.push(10);
	pq.push(40);
	pq.push(30);
	pq.push(50);
	pq.push(20);

	int value = pq.top();
	pq.pop();

	save("cpp.cpp");
}

// 코드 자체를 빨리 구현하는 것까지는 아니라도
// 기본적인 원리를 잘 파악해야 한다!
// 1법칙과 2법칙을 꼭 기억하고, 원리를 설명할 수 있어야 한다!(구현은 나중의 문제)


==========================================================================


#include <iostream>
#include <vector>
#include "save.h"

template<typename T, typename Predicate = std::less<T>>
class PriorityQueue
{
public:
	// O(logN) - 트리의 높이에 의존적이기 때문에 <- 면접으로 깊이 물어보지는 않을 것
	void push(const T& data)
	{
		// 우선 힙 구조부터 맞춰준다 - 그냥 끝에 채워 넣음
		_heap.push_back(data);

		// 도장 깨기 시작 
		int now = static_cast<int>(_heap.size()) - 1;

		// 루트 노드까지
		while (now > 0)
		{
			// 부모 노드와 비교해서 더 작으면 패배
			int next = (now - 1) / 2;	// 부모 노드의 인덱스
			//if (_heap[now] < _heap[next])
			if (_predicate(_heap[now], _heap[next]))
				break;	// while문을 빠져 나온다

			// 데이터 교체
			std::swap(_heap[now], _heap[next]);

			now = next;
		}
	}

	// O(logN) - 꺼내고 재정렬함, push와 비슷하게
	void pop()	// 데이터 꺼내기
	{
		_heap[0] = _heap.back();	// 맨 위 노드의 데이터를 맨 뒤 노드 데이터로 덮어씀
		_heap.pop_back();	// 맨 뒤에 노드 삭제

		int now = 0; // 현재 노드는 맨 위에서 시작

		while (true)
		{
			int left = 2 * now + 1;
			int right = 2 * now + 2;

			// 리프에 도달한 경우
			if (left >= (int)_heap.size())
				break;

			int next = now;

			// 왼쪽 비교
			if (_heap[next] < _heap[left])	// now가 왼쪽보다 작으면
				next = left;	// 왼쪽으로 내려감

			// 둘 중 승자를 오른쪽과 비교
			//if (right < _heap.size() && _heap[next] < _heap[right])
			if (right < _heap.size() && _predicate(_heap[next], _heap[right]))
				next = right;

			// 왼쪽/오른쪽 둘 다 현재 값보다 작으면 종료
			if (next == now)
				break;

			std::swap(_heap[now], _heap[next]);
		}
	}

	// O(1)
	T& top()	// 현재 제일 좋은 값 - 0 번째 데이터가 가장 큼
	{
		return _heap[0];
	}

	// O(1)
	bool Empty()	// 데이터가 있는지 여부 
	{
		return _heap.empty();
	}

private:
	std::vector<T> _heap;	// 데이터를 동적으로 관리할 수 있는 vecotor
	Predicate _predicate;	// 순서를 뒤바꾸고 싶다면
};
int main()
{   
	//std::vector<int> v;
	PriorityQueue<int, std::less<int> > pq;		// greater <-> less

	pq.push(10);
	pq.push(40);
	pq.push(30);
	pq.push(50);
	pq.push(20);

	int value = pq.top();
	pq.pop();

	save("cpp.cpp");
}

// 코드 자체를 빨리 구현하는 것까지는 아니라도
// 기본적인 원리를 잘 파악해야 한다!
// 1법칙과 2법칙을 꼭 기억하고, 원리를 설명할 수 있어야 한다!(구현은 나중의 문제)

// 데이터가 N개일 때, 트리의 높이는 logN
// 따라서 push, pop을 할 때 높이의 개수만큼 비교하므로, 시간 복잡도는 O(logN)


==========================================================================


#include <iostream>
#include <vector>
#include "save.h"

template<typename T, typename Predicate = std::less<T>>
class PriorityQueue
{
public:
	// O(logN) - 트리의 높이에 의존적이기 때문에 <- 면접으로 깊이 물어보지는 않을 것
	void push(const T& data)
	{
		// 우선 힙 구조부터 맞춰준다 - 그냥 끝에 채워 넣음
		_heap.push_back(data);

		// 도장 깨기 시작 
		int now = static_cast<int>(_heap.size()) - 1;

		// 루트 노드까지
		while (now > 0)
		{
			// 부모 노드와 비교해서 더 작으면 패배
			int next = (now - 1) / 2;	// 부모 노드의 인덱스
			//if (_heap[now] < _heap[next])
			if (_predicate(_heap[now], _heap[next]))
				break;	// while문을 빠져 나온다

			// 데이터 교체
			std::swap(_heap[now], _heap[next]);

			now = next;
		}
	}

	// O(logN) - 꺼내고 재정렬함, push와 비슷하게
	void pop()	// 데이터 꺼내기
	{
		_heap[0] = _heap.back();	// 맨 위 노드의 데이터를 맨 뒤 노드 데이터로 덮어씀
		_heap.pop_back();	// 맨 뒤에 노드 삭제

		int now = 0; // 현재 노드는 맨 위에서 시작

		while (true)
		{
			int left = 2 * now + 1;
			int right = 2 * now + 2;

			// 리프에 도달한 경우
			if (left >= (int)_heap.size())
				break;

			int next = now;

			// 왼쪽 비교
			if (_heap[next] < _heap[left])	// now가 왼쪽보다 작으면
				next = left;	// 왼쪽으로 내려감

			// 둘 중 승자를 오른쪽과 비교
			//if (right < _heap.size() && _heap[next] < _heap[right])
			if (right < _heap.size() && _predicate(_heap[next], _heap[right]))
				next = right;

			// 왼쪽/오른쪽 둘 다 현재 값보다 작으면 종료
			if (next == now)
				break;

			std::swap(_heap[now], _heap[next]);
		}
	}

	// O(1)
	T& top()	// 현재 제일 좋은 값 - 0 번째 데이터가 가장 큼
	{
		return _heap[0];
	}

	// O(1)
	bool Empty()	// 데이터가 있는지 여부 
	{
		return _heap.empty();
	}

private:
	std::vector<T> _heap;	// 데이터를 동적으로 관리할 수 있는 vecotor
	Predicate _predicate;	// 순서를 뒤바꾸고 싶다면
};
int main()
{   
	//std::vector<int> v;
	PriorityQueue<int, std::less<int> > pq;		// greater <-> less
	// 이렇게 하는 방법이 기억이 안 나면 값을 넣을 때 음수로 넣자
	// pq.push(-10); 이런 식으로
	// 꺼낼 때도 음수로
	// int value = -pq.top();

	pq.push(10);
	pq.push(40);
	pq.push(30);
	pq.push(50);
	pq.push(20);

	int value = pq.top();
	pq.pop();

	save("cpp.cpp");
}

// 코드 자체를 빨리 구현하는 것까지는 아니라도
// 기본적인 원리를 잘 파악해야 한다!
// 1법칙과 2법칙을 꼭 기억하고, 원리를 설명할 수 있어야 한다!(구현은 나중의 문제)

// 데이터가 N개일 때, 트리의 높이는 logN
// 따라서 push, pop을 할 때 높이의 개수만큼 비교하므로, 시간 복잡도는 O(logN)



// 코드는 그림 그리면서 한 번 분석해보고, 구현은 아직 당장 해야하는 건 아니니까
// 원리를 먼저 이해하는 게 가장 중요!
// 시간 복잡도는 암기해놓기!